# redis

- redis中zset的实现，跳表
  - https://zhuanlan.zhihu.com/p/148667260
- redis项目中应用 template
- https://www.cnblogs.com/EasonJim/p/7803067.html
- redis的三个问题
  - 缓存穿透：数据库和缓存都没有的key大量请求
    - 缓存null值
    - 布隆过滤器，把可能的请求先缓存在过滤器中，当请求过来时，先判断布隆过滤器有没有，如果没有直接返回null，避免大量无效请求直接落在数据库上，用一个布尔值就可以存储，比较简单。
  - 缓存击穿：数据库有，缓存没有
    - 热点数据延长过期时间或者设置不过期
    - 互斥锁
  - 缓存雪崩
    - 将redis做成高可用
    - 缓存预热等
    - 过期时间设置成随机分散开等。
- redis和map做缓存的区别
  - 首先他们都是高速且轻量的，其次，缓存分为本地缓存和分布式缓存，map的本地缓存，生命周期随着jvm的结束而结束，并且，在多个实例的情况下，map这类本地缓存每一个实例都要保存一份，缓存不具有一致性
- redis或者memcached之类的分布式缓存，在多实例的情况下，各实例公用一份缓存，具有一致性
- redis和memcached的区别
  - redis支持复杂的数据结构
  - redis原生支持集群模式
  - redis支持数据持久化
  - 性能上，redis使用单核，而memcached使用多核，数据量小时，redis更有优秀，数据量大时，memcached更为优秀
  - 线程模型：
    - redis内部使用file event handler（文件时间处理器），这个文件事件处理器是单线程的，所以redis才叫做单线程的模型，
    - 它采用 IO 多路复用机制同时监听多个 socket，根据 socket 上的事件来选择对应的事件处理器进行处理。
    - IO 多路复用程序会监听多个 socket，会将 socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。
- 为什么redis单线程模型效率也能那么高？
  - 纯内存操作
  - 核心是基于非阻塞的io多路复用机制
  - 单线程反而避免了多线程的频繁上下文切换问题
- 在windows下配置redis的一主二从三哨兵模式
  - https://blog.csdn.net/xiaokailele/article/details/72597971
- redis的基本类型：string，hash，list，set，sorted set
- redis哨兵主备切换的数据丢失问题
  - 异步复制问题
    - 在主备切换的过程中，因为master -> slave的复制是异步的，所以可能有部分数据还没复制到slave，master就宕机了，此时这些部分数据就丢失了
  - 集群脑裂问题
    - 某个master所在机器突然脱离了正常的网络，跟其他slave机器不能连接，但是实际上master还运行着，此时哨兵可能就会认为master宕机了，然后开启选举，将其他slave切换成了master，这个时候，集群里就会有两个master，也就是所谓的脑裂
    - 此时虽然某个slave被切换成了master，但是可能client还没来得及切换到新的master，还继续写向旧master的数据可能也丢失了
  - 解决方案
    - 通过设置两个参数
      - min-slaves-to-write 1
      - min-slaves-max-lag 10
      - 以上要求，至少有一个slave，数据复制和同步的延迟都超过了10s，那么这个时候，master就不会再接收任何请求了，上面两个配置可以减少异步复制和脑裂导致的数据丢失。
- 持久化方式
  - RDB
    - 通过bgsave或者save生成一个在硬盘上的rdb文件进行持久化，二者的底层都是调用rdbSAVE这个函数进行持久化操作，只是有是否阻塞这个区别
    - 持久化条件在redisServer结构体中以一个链表的形式存在
    - dirty计数器和lastsave这两个变量，他们保存着上次RDB持久化的时间（lastsave）和之后又发生了几次数据修改（dirty）。
       Redis系统中的serverCron函数会每隔100毫秒执行一次，执行时会遍历链表检查RDB持久化条件是否满足，根据dirty和lastsave这两个变量与条件进行对比，判断满足条件后进行持久化，然后刷新这两个值。
  - AOF
    - aof通过保存redis服务器所执行的写命令来记录数据库状态的
    - AOF持久化功能主要分为三个步骤，分别是命令追加，文件写入，文件同步。
      - 在redisServer结构体中有个AOF缓冲区变量，用户向服务器发送的命令会追加到缓冲区的末尾等待处理，这就是**命令追加**
      - 之后调用flushAppendOnlyFile函数尝试把命令写入到AOF文件，这是**文件写入**和**文件同步**。
      - 在命令追加之后，要保存的命令此时存在于Redis命令缓冲区，在执行文件写入之后这些命令会进入操作系统负责管辖的内存区域，也就是离开了AOF命令缓冲区，但是依然在内存中。在执行了文件同步之后才会更新到磁盘的AOF文件。
      - 在flushAppendOnlyFile中Redis会根据不同的配置信息进行文件写入和文件同步工作。
        - always：将命令缓冲区的内容进行文件写入并通过文件同步操作更新到AOF文件。
        - everysec：对命令缓存区进行文件写入，如果距离上次文件同步的时间超过1秒就进行文件同步。
        - no：进行文件写入，不进行文件同步操作，更新到磁盘的事件交给操作系统自行决定执行。
        - （ps：如果配置为no，那么操作系统可能会把命令放置到一块内存，直到这块内存区被填满以后才会把命令更新到AOF文件，这样虽然提高了效率，但是却带来了安全问题。fsync和fdatasync这两个函数能够帮忙，他们能够让操作系统的缓存中的数据立刻写入硬盘，保证了安全性。
    - aof优化手段：aof重写
  - 混合持久化（4.0新加）
    - 混合持久化顾名思义就是把AOF持久化和RDB持久化混合在一起使用。混合产生的文件有一半是AOF持久化文件，一半时RDB持久化文件
    - 混合持久化则是在AOF重写时，直接用类似RDB的方式把数据库的状态（也就是现有的数据）保存起来，之后在尾部追加重写缓冲池的命令，这样生成的持久化文件既包括RDB文件格式数据，也包含AOF文件格式的命令，因此称为混合持久化。
- redis的三个问题：缓存击穿，缓存穿透，缓存雪崩
  - 缓存击穿和缓存雪崩的区别在于缓存击穿针对某一key缓存缓存雪崩则是很多key
- 应用场景
  - 一般来说RDB的更新效率是要低于AOF的，因为它要进行条件判断，而AOF是时刻监控命令。因此AOF的开销也要大于RDB，如果对数据安全要求不高，追求效率就选择RDB。如果追求高安全性就选择AOF。
     如果RDB和AOF都开启的话，因为AOF持久化更精准，所以**Redis在重启时会选择AOF文件**进行恢复数据。
- 过期数据的影响
  - 不论是RDB还是AOF在生成相应持久化文件时都会过滤掉过期数据。在Redis重启恢复数据时也会进行过期数据过滤，所以不用担心过期数据的问题。
- 怎么实现redis的高可用
  - 主从架构（master和slave），缺点就是master如果宕机的话
  - 哨兵：
    - 同时监视多个主从服务器，并且在被监视的master宕机之后，将一个slave升级成master
- redis集群：redis集群是redis提供的分布式数据存储方案 ，集群通过数据分片来进行数据共享，同时提供复制和故障转移的功能。
  - 节点a收到客户端的clustermeet命令，
  - a根据收到的ip地址和端口号向b发送一条meet消息
  - 节点b收到meet消息之后返回pong
  - a知道b收到了meet消息，返回ping，握手成功
  - 最后a通过gossip协议把节点b的信息传播给集群中的所有其他节点，其他节点也将和b进行握手。
- redis通过集群分片的形式来保存数据，整个集群数据库被分为16384个slot，集群中的每个节点可以处理0-16384个slot，当数据库16384个slot都有节点在处理时，集群处于上线状态，反之只要有一个slot没有得到处理都会处理下线状态。通过cluster addslots命令可以将slot指派给对应节点处理。
- redis的事物机制:通过multi，exec，watch命令来实现事物机制，事物执行过程将一系列多个命令按照顺序一次性执行，并且在执行期间，事物不会被中断，也不会去执行其他客户端的其他请求，直到所有命令执行完毕
  - watch机制本身就是一个cas机制，被监视的key会保存在一个链表中，如果某个key被修改了，那么redis_dirty_cas标志就会被打开，这时服务器会拒绝执行事务。