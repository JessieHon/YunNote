# 数据库

- 数据库三大范式
  - 第一范式
    - 所有属性都不可再分，即数据项不可分
    - 确保每列的原子性
  - 第二范式：数据库表中的每一列都与主键相关
  - 第三范式：数据表中的每一列都和主键直接相关，而不是间接相关
- mybatis原理
  - 读取核心配置文件并返回inputStream流对象
  - 根据inputstream流对象解析出configuration对象，然后创建sqlSession工厂对象
  - 根据一系列属性从sqlsessionFactory工厂创建sqlSession
  - 从sqlSession中调用Executor执行数据库操作，生成具体的sql指令
  - 对执行结果进行二次封装
  - 提交事务
- 数据库引擎的对比
  -  InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务； 
  - InnoDB支持外键，而MyISAM不支持。
  - InnoDB支持表、行(默认)级锁，而MyISAM支持表级锁
    -  InnoDB的行锁是实现在索引上的，而不是锁在物理行记录上。潜台词是，如果访问没有命中索引，也无法使用行锁，将要退化为表锁。
    - innodb的行锁分为共享锁和排他锁
      - 可以通过
  - InnoDB表必须有唯一索引（如主键）（用户没有指定的话会自己找/生产一个隐藏列Row_id来充当默认主键），而Myisam可以没有
    - 为什么innodb推荐使用自增主键
      - 如果设置了主键，innodb会选择主键作为聚集索引，内部实现是b+树，采用自增主键时，每次插入新纪录，记录会顺序添加到当前索引节点的后续位置。
      - 主键的顺序按照数据记录插入顺序排列，自动有序，当一页写满，会自动开辟一个新页。
  - myisam崩溃后不易恢复，innodb容易恢复
- 声明式事物
  - 原理
    - Spring 的声明式事务管理在底层是建立在 AOP 的基础之上的。其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。
    - 声明式事务最大的优点就是不需要通过编程的方式管理事务，这样就不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明（或通过等价的基于标注的方式），便可以将事务规则应用到业务逻辑中。因为事务管理本身就是一个典型的横切逻辑，正是 AOP 的用武之地。Spring 开发团队也意识到了这一点，为声明式事务提供了简单而强大的支持。
    - 和编程式事务相比，声明式事务唯一不足地方是，后者的最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。但是即便有这样的需求，也存在很多变通的方法，比如，可以将需要进行事务管理的代码块独立为方法等等。
  - 使用方式
    - 基于<tx>和<aop>命名空间的xml配置文件；
    - 基于@Transactional注解。
      - 使用该注解的注意点
- 数据切分
  - 垂直切分
  - 水平切分
- sql优化https://database.51cto.com/art/202008/624194.htm
  - 总结
    - 最大化利用索引
    - 尽可能避免全表扫描
      - 尽量避免使用 in 和 not in，会导致引擎走全表扫描，
        - 用between代替
        - 如果是子查询，用exists代替
      - 尽量避免使用 or，会导致数据库引擎放弃索引进行全表扫描
        - 可以用 union 代替 
      - 尽量避免进行 null 值的判断，会导致数据库引擎放弃索引进行全表扫描
        - 可以给字段添加默认值 0，对 0 值进行判断
    - 减少无效数据的查询