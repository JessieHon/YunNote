# RPC框架源码

- 背景
  - 随着业务功能的增多，单体应用存在代码重用性低
  - 不利于各业务团队进行合作，开发效率低的问题
  - 比喻：活字印刷
- 目标
  - 提升系统的稳定性
  - 降低系统耦合性，提高代码重用
  - 适用于大公司
- 解决方案
  - RPC框架应运而生，将不同的业务分到多个应用中去，让不同的应用分别承担不同的功能是解决这些问题的必杀技。
- 效果
- 核心要素
  - 生产者
  - 消费者
  - 中央管理 
    - 作用：记录生产者和消费者情况，并且记录调用情况
    - 服务治理：
    - 服务发现：注册服务、ip、接口、自动注册、轮询（心跳：需要记录时间）、服务标记
    - 记录消费者调用情况
  - 传输协议
    - 底层实现：基于TCP
  - 流量控制
  - 权限控制
  - 传输序列化
    - 加快传输速度
- 关系型数据库和非关系型数据库的对比
  - 关系型擅长关联计算
  - 非关系型数据库将数据做切割，速度比较快，但是不擅长关联计算
- 数据库做分表、Hadoop、hive
-  zookeeper的原理
  - 目录式
- dubbo和spring cloud区别于对比：spring cloud传输速度慢一点
- 生产者原理
  - 判断请求业务是否合理了，有准备时间
- 消费者原理
- 怎么进行流量控制
- 怎么进行权限控制
- 怎么解决生产者崩溃后的消费者信息丢失问题
- 生产者宕机或者新增生产者怎么通知消费者
- 序列化如何绕开反射、buffer
- tomcat原理
- buffer
  - 所有的buffer都是数组，数据压缩，批量传输
  - int a=24   实际上占一个页块大小（4kb），分成1024块，需要用10位存储地址
  - cpu每次和内存进行交换需要100个时钟周期
  - 一个存储单位只能存储一个变量，String a=“你好” 也是占4kb
  - int[] arr=new int[1024]，通过数组方式减少存储消耗，在内存存储时压缩变量，充分利用存储空间
  - buffer使用场景：增删改查之后，元素所占内存大小固定不变
  - 所有类型都可以转成byte类型
  - 
- netty
- 序列化方式
  - 一般通过反射，但是效率低
  - protocol buffer（推荐）

























