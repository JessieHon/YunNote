# java异常处理机制

- 异常处理

  - 声明异常
  - 抛出异常
  - 捕获异常
  - 处理异常

- 背景

  - 异常处理机制能让程序在异常发生时，按照代码的预先设定的异常处理逻辑，针对性地处理异常，让程序尽最大可能恢复正常并继续执行，且保持代码的清晰。
  - Java中的异常可以是函数中的语句执行时引发的，也可以是程序员通过throw 语句手动抛出的，只要在Java程序中产生了异常，就会用一个对应类型的异常对象来封装异常，JRE就会试图寻找异常处理程序来处理异常。
  - Throwable类是Java异常类型的顶层父类，一个对象只有是 Throwable 类的（直接或者间接）实例，他才是一个异常对象，才能被异常处理机制识别。JDK中内建了一些常用的异常类，我们也可以自定义异常。

- ![image-20201121213103682](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201121213103682.png)

- `错误：`Error类以及他的子类的实例，代表了JVM本身的错误。错误不能被程序员通过代码处理，Error很少出现。因此，程序员应该关注Exception为父类的分支下的各种异常类。

- `异常：`Exception以及他的子类，代表程序运行时发送的各种不期望发生的事件。可以被Java异常处理机制使用，是异常处理的核心。

- 总体上，根据javac对异常的处理要求，异常分为两类

  - 非检查异常
    - Error 和 RuntimeException  以及他们的子类。javac在编译时，不会提示和发现这样的异常，不要求在程序处理这些异常。所以如果愿意，我们可以编写代码处理（使用try…catch…finally）这样的异常，也可以不处理。对于这些异常，我们应该修正代码，而不是去通过异常处理器处理 。这样的异常发生的原因多半是代码写的有问题。
  - 检查异常
    - 除了Error 和  RuntimeException的其它异常。javac强制要求程序员为这样的异常做预备处理工作（使用try…catch…finally或者throws）。在方法中要么用try-catch语句捕获它并处理，要么用throws子句声明抛出它，否则编译不会通过。这样的异常一般是由程序的运行环境导致的。因为程序可能被运行在各种未知的环境下，而程序员无法干预用户如何使用他编写的程序，于是程序员就应该为这样的异常时刻准备着。如SQLException , IOException,ClassNotFoundException 等。

- InterruptedException 异常： 当一个方法后面声明可能会抛出InterruptedException 异常时，说明该方法是可能会花一点时间，但是可以取消的方法。

  - 抛InterruptedException的代表方法有：
    -  java.lang.Object 类的 wait 方法
    -  java.lang.Thread 类的 sleep 方法
    - java.lang.Thread 类的 join 方法
  - interrupt方法其实只是改变了中断状态而已。而sleep、wait和join这些方法的内部会不断的检查中断状态的值，从而自己抛出InterruptEdException。
  
- 异常处理的基本语法

  ```text
  try{
       //try块中放可能发生异常的代码。
       //如果执行完try且不发生异常，则接着去执行finally块和finally后面的代码（如果有的话）。
       //如果发生异常，则尝试去匹配catch块。
  }catch(SQLException SQLexception){
      //每一个catch块用于捕获并处理一个特定的异常，或者这异常类型的子类。Java7中可以将多个异常声明在一个catch中。
      //catch后面的括号定义了异常类型和异常参数。如果异常与之匹配且是最先匹配到的，则虚拟机将使用这个catch块来处理异常。
      //在catch块中可以使用这个块的异常参数来获取异常的相关信息。异常参数是这个catch块中的局部变量，其它块不能访问。
      //如果当前try块中发生的异常在后续的所有catch中都没捕获到，则先去执行finally，然后到这个函数的外部caller中去匹配异常处理器。
      //如果try中没有发生异常，则所有的catch块将被忽略。
  }catch(Exception exception){
      //...
  }finally{
      //finally块通常是可选的。
     //无论异常是否发生，异常是否匹配被处理，finally都会执行。
     //一个try至少要有一个catch块，否则， 至少要有1个finally块。但是finally不是用来处理异常的，finally不会捕获异常。
    //finally主要做一些清理工作，如流的关闭，数据库连接的关闭等。 
  }
  ```

- 需要注意的地方
  - try块中的局部变量和catch块中的局部变量（包括异常变量），以及finally中的局部变量，他们之间不可共享使用。
  - 每一个catch块用于处理一个异常。异常匹配是按照catch块的顺序从上往下寻找的，只有第一个匹配的catch会得到执行。匹配时，不仅运行精确匹配，也支持父类匹配，因此，如果同一个try块下的多个catch异常类型有父子关系，应该将子类异常放在前面，父类异常放在后面，这样保证每个catch块都有存在的意义。
  - java中，异常处理的任务就是将执行控制流从异常发生的地方转移到能够处理这种异常的地方去。也就是说：当一个函数的某条语句发生异常时，这条语句的后面的语句不会再执行，它失去了焦点。执行流跳转到最近的匹配的异常处理catch代码块去执行，异常被处理完后，执行流会接着在“处理了这个异常的catch代码块”后面接着执行。
  
- throws函数声明
  - throws声明：如果一个方法内部的代码会抛出检查异常（checked exception），而方法自己又没有完全处理掉，则javac保证你必须在方法的签名上使用throws关键字声明这些可能抛出的异常，否则编译不通过。
  - throws是另一种处理异常的方式，它不同于try…catch…finally，throws仅仅是将函数中可能出现的异常向调用者声明，而自己则不具体处理。
  - 采取这种异常处理的原因可能是：方法本身不知道如何处理这样的异常，或者说让调用者处理更好，调用者需要为可能发生的异常负责。
  
- finally块
  - 只有一种方法让finally块不执行：System.exit()。因此finally块通常用来做资源释放操作：关闭文件，关闭数据库连接等等。
  - 良好的编程习惯是：在try块中打开资源，在finally块中清理释放这些资源。
  
- throws异常抛出语句
  - 程序员也可以通过throw语句手动显式的抛出一个异常。throw语句的后面必须是一个异常对象。
  - throw 语句必须写在函数中，执行throw 语句的地方就是一个异常抛出点，它和由JRE自动形成的异常抛出点没有任何差别。
  
- 异常的链化
  - 异常链化:以一个异常对象为参数构造新的异常对象。新的异对象将包含先前异常的信息。这项技术主要是异常类的一个带Throwable参数的函数来实现的。这个当做参数的异常，我们叫他根源异常（cause）。
  - 查看Throwable类源码，可以发现里面有一个Throwable字段cause，就是它保存了构造时传递的根源异常参数。这种设计和链表的结点类设计如出一辙，因此形成链也是自然的了。
  
- 自定义异常
  - 如果要自定义异常类，则扩展Exception类即可，因此这样的自定义异常都属于检查异常（checked exception）
  - 如果要自定义非检查异常，则扩展自RuntimeException。
  - 按照国际惯例，自定义的异常应该总是包含如下的构造函数：
    - 一个无参构造函数
    - 一个带有String参数的构造函数，并传递给父类的构造函数。
    - 一个带有String参数和Throwable参数，并都传递给父类构造函数
    - 一个带有Throwable 参数的构造函数，并传递给父类的构造函数。
  
- 异常的处理事项
  - 当子类重写父类的带有 throws声明的函数时，其throws声明的异常必须在父类异常的可控范围内——用于处理父类的throws方法的异常处理器，必须也适用于子类的这个带throws方法 。这是为了支持多态。
  - Java中的异常是线程独立的，线程的问题应该由线程自己来解决，而不要委托到外部，也不会直接影响到其它线程的执行
  
- finally和return块的关系
  - finally中的return会覆盖try和catch中的返回值
  - 如果try中有return，而finally中有代码需要执行，会先将return的值暂存起来，执行完finally块中的内容再讲之前的结果return



